<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 模型檢視器與 AR 體驗</title>
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
    
    <!-- 添加相機權限處理腳本 -->
    <script>
        // 在AR.js初始化前處理相機權限
        window.addEventListener('camera-init', function(event) {
            console.log('相機初始化中...');
        });
        
        window.addEventListener('camera-error', function(error) {
            console.error('相機錯誤:', error);
            alert('無法訪問相機。請確保已授予相機權限，然後重新加載頁面。');
        });
        
        // 在相機流開始時確保背景透明
        window.addEventListener('camera-started', function() {
            console.log('相機流已開始');
            // 確保鴨子模型顯示
            setTimeout(ensureDuckVisible, 500);
        });
        
        // 處理資源載入錯誤
        window.addEventListener('error', function(event) {
            console.error('資源載入錯誤:', event);
            // 檢查是否是AR.js相關錯誤
            if (event.filename && event.filename.includes('aframe-ar.js')) {
                console.warn('AR.js資源載入錯誤，嘗試繼續運行');
            }
        }, true);
        
        // 處理未捕獲的Promise錯誤
        window.addEventListener('unhandledrejection', function(event) {
            console.error('未處理的Promise錯誤:', event.reason);
            
            // 檢查是否是相機參數404錯誤
            if (event.reason && event.reason.message && 
                event.reason.message.includes('404')) {
                console.warn('忽略AR.js相關的404錯誤，繼續顯示AR場景');
                event.preventDefault();
                event.stopPropagation();
                
                // 嘗試強制初始化AR場景
                setTimeout(function() {
                    const arScene = document.querySelector('a-scene');
                    if (arScene && typeof arScene.emit === 'function') {
                        console.log('嘗試手動觸發場景初始化');
                        arScene.emit('loaded');
                        
                        // 確保鴨子模型可見
                        const duckEntity = document.getElementById('duck');
                        if (duckEntity) {
                            duckEntity.setAttribute('visible', 'true');
                            duckEntity.object3D.visible = true;
                            console.log('確保鴨子模型可見');
                        }
                    }
                }, 1000);
                
                // 如果AR.js初始化失敗，嘗試使用基本的A-Frame場景
                setTimeout(function() {
                    const arScene = document.querySelector('a-scene');
                    if (arScene && (!arScene.systems || !arScene.systems.arjs || !arScene.systems.arjs._arToolkitContext)) {
                        console.warn('AR.js初始化失敗，使用基本的A-Frame場景');
                        
                        // 添加基本相機和光源
                        if (!document.querySelector('a-entity[camera][look-controls]')) {
                            const camera = document.createElement('a-entity');
                            camera.setAttribute('camera', '');
                            camera.setAttribute('look-controls', '');
                            camera.setAttribute('position', '0 1.6 0');
                            arScene.appendChild(camera);
                        }
                        
                        if (!document.querySelector('a-light')) {
                            const light = document.createElement('a-light');
                            light.setAttribute('type', 'ambient');
                            light.setAttribute('color', '#FFF');
                            light.setAttribute('intensity', '0.8');
                            arScene.appendChild(light);
                            
                            const dirLight = document.createElement('a-light');
                            dirLight.setAttribute('type', 'directional');
                            dirLight.setAttribute('color', '#FFF');
                            dirLight.setAttribute('intensity', '0.8');
                            dirLight.setAttribute('position', '1 1 1');
                            arScene.appendChild(dirLight);
                        }
                        
                        // 確保鴨子模型可見
                        const duckEntity = document.getElementById('duck');
                        if (duckEntity) {
                            duckEntity.setAttribute('position', '0 0 -2');
                            duckEntity.setAttribute('visible', 'true');
                            duckEntity.object3D.visible = true;
                        }
                        
                        // 設置背景顏色
                        arScene.setAttribute('background', 'color: #87CEEB');
                    }
                }, 5000);
            }
        });
        
        // 在頁面加載完成後，確保AR.js正確初始化
        window.addEventListener('load', function() {
            if (isARMode()) {
                console.log('AR模式：確保AR.js正確初始化');
                
                // 確保AR場景可見
                const arScene = document.querySelector('a-scene');
                if (arScene) {
                    arScene.style.visibility = 'visible';
                    arScene.style.opacity = '1';
                    
                    // 檢查AR.js是否已經載入
                    if (typeof AFRAME !== 'undefined' && AFRAME.scenes.length > 0) {
                        console.log('AFRAME已載入，場景數量:', AFRAME.scenes.length);
                        
                        // 嘗試手動初始化AR系統
                        try {
                            const scene = AFRAME.scenes[0];
                            if (scene.hasLoaded) {
                                console.log('場景已加載');
                            } else {
                                console.log('等待場景加載');
                                scene.addEventListener('loaded', function() {
                                    console.log('場景加載完成');
                                });
                            }
                        } catch (e) {
                            console.error('初始化AR系統時出錯:', e);
                        }
                    }
                }
            }
        });
        
        // 在頁面加載完成後，初始化AR.js
        document.addEventListener('DOMContentLoaded', function() {
            console.log('頁面加載完成');
            
            // 檢測是否為移動設備
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            console.log('是否為移動設備:', isMobile);
            
            // 獲取覆蓋層元素
            const overlay = document.getElementById('permission-overlay');
            const arScene = document.querySelector('a-scene');
            
            // 添加模型加載事件監聽器
            document.addEventListener('model-loaded', function(event) {
                console.log('模型已加載:', event);
                // 確保鴨子模型顯示
                setTimeout(ensureDuckVisible, 100);
            });
            
            // 監聽duck模型的加載事件
            const duckModel = document.querySelector('#duck');
            if (duckModel) {
                duckModel.addEventListener('model-loaded', function() {
                    console.log('鴨子模型已加載');
                    // 確保鴨子模型顯示
                    ensureDuckVisible();
                });
            }
            
            // 初始隱藏AR場景，直到權限授予
            if (arScene) {
                arScene.style.visibility = 'hidden';
                arScene.style.opacity = '0';
            }
            
            // 檢查本地存儲中是否已授予權限
            const permissionGranted = localStorage.getItem('cameraPermissionGranted') === 'true';
            
            // 如果本地存儲中已授予權限，直接顯示AR場景
            if (permissionGranted) {
                console.log('本地存儲中已授予相機權限');
                // 隱藏覆蓋層
                overlay.style.display = 'none';
                // 顯示AR場景
                if (arScene) {
                    arScene.style.visibility = 'visible';
                    arScene.style.opacity = '1';
                    
                    // 確保AR場景正確初始化
                    setTimeout(function() {
                        // 觸發場景初始化
                        if (typeof arScene.emit === 'function') {
                            arScene.emit('loaded');
                            console.log('手動觸發場景loaded事件');
                            
                            // 確保AR.js系統初始化
                            if (arScene.systems && arScene.systems.arjs) {
                                const arSystem = arScene.systems.arjs;
                                if (typeof arSystem.restart === 'function') {
                                    arSystem.restart();
                                    console.log('重新啟動AR.js系統');
                                }
                            }
                        }
                        
                        // 確保鴨子模型可見
                        const duckEntity = document.getElementById('duck');
                        if (duckEntity) {
                            duckEntity.setAttribute('visible', 'true');
                            duckEntity.object3D.visible = true;
                            console.log('確保鴨子模型可見');
                        }
                        
                        // 調用統一的鴨子顯示函數
                        ensureDuckVisible();
                    }, 1000);
                }
                return;
            }
            
            // 如果是移動設備，嘗試使用更簡單的權限檢查方法
            if (isMobile) {
                console.log('移動設備：使用簡化的權限檢查');
                // 顯示覆蓋層
                overlay.style.display = 'flex';
                
                // 修改授予權限按鈕文字，使其更清晰
                const grantButton = document.getElementById('grant-permission');
                if (grantButton) {
                    grantButton.textContent = '點擊這裡開始AR體驗';
                    grantButton.style.fontSize = '20px';
                    grantButton.style.padding = '15px 30px';
                }
                
                return;
            }
            
            // 如果本地存儲中沒有授予權限，檢查瀏覽器權限狀態
            if (navigator.permissions && navigator.permissions.query) {
                navigator.permissions.query({name: 'camera'}).then(function(result) {
                    console.log('相機權限狀態:', result.state);
                    
                    if (result.state === 'granted') {
                        // 已經有權限，設置本地存儲標記
                        localStorage.setItem('cameraPermissionGranted', 'true');
                        // 隱藏覆蓋層
                        overlay.style.display = 'none';
                        // 顯示AR場景
                        if (arScene) {
                            arScene.style.visibility = 'visible';
                            arScene.style.opacity = '1';
                            
                            // 確保AR場景正確初始化
                            setTimeout(function() {
                                // 觸發場景初始化
                                if (typeof arScene.emit === 'function') {
                                    arScene.emit('loaded');
                                    console.log('手動觸發場景loaded事件');
                                }
                                
                                // 確保鴨子模型可見
                                const duckEntity = document.getElementById('duck');
                                if (duckEntity) {
                                    duckEntity.setAttribute('visible', 'true');
                                    duckEntity.object3D.visible = true;
                                    console.log('確保鴨子模型可見');
                                }
                                
                                // 調用統一的鴨子顯示函數
                                ensureDuckVisible();
                            }, 1000);
                        }
                    } else {
                        // 顯示覆蓋層
                        overlay.style.display = 'flex';
                    }
                    
                    // 監聽權限狀態變化
                    result.onchange = function() {
                        console.log('相機權限狀態變更為:', this.state);
                        if (this.state === 'granted') {
                            // 權限已授予，設置本地存儲標記
                            localStorage.setItem('cameraPermissionGranted', 'true');
                            // 隱藏覆蓋層
                            overlay.style.display = 'none';
                            // 顯示AR場景
                            if (arScene) {
                                arScene.style.visibility = 'visible';
                                arScene.style.opacity = '1';
                                
                                // 重新載入頁面以確保AR場景正確初始化
                                window.location.reload();
                            }
                        }
                    };
                }).catch(function(error) {
                    console.error('無法查詢權限狀態:', error);
                    // 顯示覆蓋層
                    overlay.style.display = 'flex';
                });
            } else {
                console.warn('瀏覽器不支持權限查詢API');
                // 顯示覆蓋層
                overlay.style.display = 'flex';
            }
        });
    </script>
    
    <!-- 使用單一的THREE導入方式 -->
    <script src="https://unpkg.com/three@0.126.0/build/three.min.js"></script>
    <script>
        // 手動創建GLTFLoader如果它不存在
        if (typeof THREE !== 'undefined' && typeof THREE.GLTFLoader === 'undefined') {
            console.log('手動定義GLTFLoader');
            THREE.GLTFLoader = function() {
                this.load = function(url, onLoad, onProgress, onError) {
                    console.log('使用替代的GLTFLoader載入:', url);
                    
                    // 創建一個簡單的鴨子模型來替代
                    const duckObject = new THREE.Group();
                    
                    // 身體 - 橢圓
                    const bodyGeometry = new THREE.SphereGeometry(0.5, 32, 32);
                    bodyGeometry.scale(1, 0.7, 1.5);
                    const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0xF9D71C });
                    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    duckObject.add(body);
                    
                    // 頭
                    const headGeometry = new THREE.SphereGeometry(0.3, 32, 32);
                    const headMaterial = new THREE.MeshPhongMaterial({ color: 0xF9D71C });
                    const head = new THREE.Mesh(headGeometry, headMaterial);
                    head.position.set(0, 0.3, 0.6);
                    duckObject.add(head);
                    
                    // 嘴
                    const beakGeometry = new THREE.ConeGeometry(0.1, 0.4, 32);
                    const beakMaterial = new THREE.MeshPhongMaterial({ color: 0xFFA500 });
                    const beak = new THREE.Mesh(beakGeometry, beakMaterial);
                    beak.rotation.x = Math.PI / 2;
                    beak.position.set(0, 0.2, 0.9);
                    duckObject.add(beak);
                    
                    // 眼睛
                    const eyeGeometry = new THREE.SphereGeometry(0.05, 32, 32);
                    const eyeMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
                    
                    const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    leftEye.position.set(0.15, 0.4, 0.7);
                    duckObject.add(leftEye);
                    
                    const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    rightEye.position.set(-0.15, 0.4, 0.7);
                    duckObject.add(rightEye);
                    
                    // 包裝為GLTFResult
                    const result = { scene: duckObject };
                    
                    // 調用成功回調
                    if (onLoad) {
                        setTimeout(() => {
                            onLoad(result);
                        }, 500);
                    }
                };
            };
        }
        
        // 修補AR.js的相機參數載入
        window.addEventListener('load', function() {
            // 等待一段時間後檢查AR.js是否已載入
            setTimeout(function() {
                if (typeof AFRAME !== 'undefined' && AFRAME.scenes.length > 0) {
                    const scene = AFRAME.scenes[0];
                    
                    // 檢查是否有AR系統
                    if (scene.systems && scene.systems.arjs) {
                        const arSystem = scene.systems.arjs;
                        
                        // 修補相機參數載入方法
                        if (arSystem._arToolkitContext && arSystem._arToolkitContext.arController) {
                            console.log('AR.js已初始化，無需修補');
                        } else {
                            console.log('嘗試修補AR.js初始化');
                            
                            // 手動觸發場景初始化
                            if (typeof scene.emit === 'function') {
                                scene.emit('ar-camera-ready');
                                console.log('手動觸發ar-camera-ready事件');
                            }
                        }
                    }
                }
            }, 2000);
        });
    </script>
    <script src="https://unpkg.com/three@0.126.0/examples/js/loaders/GLTFLoader.js"></script>
    <script>
        // 確保THREE已經載入
        if (typeof THREE === 'undefined') {
            console.error('THREE is not defined. Ensure three.js is properly loaded.');
        } else {
            console.log('THREE is loaded:', THREE.REVISION);
        }
    </script>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        .ar-section {
            height: 100vh;
            position: relative;
        }
        
        .ar-scene {
            width: 100%;
            height: 100%;
        }
        
        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: flex;
            gap: 10px;
        }
        
        button {
            padding: 8px 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        .section-title {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            z-index: 10;
        }
        
        .info-text {
            position: absolute;
            bottom: 80px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            z-index: 10;
        }
        
        /* 添加覆蓋層樣式 */
        .permission-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            text-align: center;
        }
        
        .permission-overlay h2 {
            margin-bottom: 20px;
        }
        
        .permission-overlay p {
            margin-bottom: 30px;
            max-width: 80%;
        }
        
        .permission-overlay button {
            padding: 12px 24px;
            font-size: 18px;
            background-color: #2196F3;
        }
    </style>
</head>
<body>
    <!-- 相機權限覆蓋層 -->
    <div id="permission-overlay" class="permission-overlay">
        <h2>AR 小鴨體驗</h2>
        <p>此體驗需要使用您的相機。請點擊下方按鈕授予相機權限。</p>
        <button id="grant-permission">授予相機權限</button>
        <p style="margin-top: 20px; font-size: 12px;">如果遇到問題，請嘗試 <a href="#" id="reset-permission" style="color: white; text-decoration: underline;">重置權限</a></p>
    </div>
    
    <div class="container">
        <!-- AR 部分 -->
        <div class="ar-section">
            <div class="section-title">AR 小鴨體驗</div>
            <a-scene 
                class="ar-scene"
                embedded
                arjs="trackingMethod: best; sourceType: webcam; detectionMode: mono_and_matrix; debugUIEnabled: false; sourceWidth:1280; sourceHeight:960; displayWidth: 1280; displayHeight: 960;"
                renderer="logarithmicDepthBuffer: true; alpha: true;"
                gesture-detector
                vr-mode-ui="enabled: false"
                device-orientation-permission-ui="enabled: false"
            >
                <a-assets>
                    <a-asset-item id="duck-model" src="https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Duck/glTF/Duck.gltf" response-type="arraybuffer" crossorigin="anonymous"></a-asset-item>
                </a-assets>
                
                <!-- 使用a-entity直接在相機前方放置模型，不需要標記 -->
                    <a-entity
                    id="duck"
                    position="0 0 -2"
                    rotation="90 0 0"
                    scale="0.3 0.3 0.3"
                    visible="true"
                    shadow="cast: true; receive: true"
                    gltf-model="#duck-model"
                    class="clickable"
                    gesture-handler="minScale: 0.1; maxScale: 1; sensitivityX: 2; sensitivityY: 2"
                    ></a-entity>
                
                <!-- 備用：使用盒子模型，如果鴨子模型加載失敗可以顯示 -->
                <a-box id="backup-model" position="0 0 -2" scale="0.2 0.2 0.2" color="yellow" visible="false"></a-box>
                
                <a-entity camera look-controls></a-entity>
            </a-scene>
            <div class="controls">
                <button id="reset-view">重置視角</button>
                <button id="auto-rotate">自動旋轉</button>
                <button id="move-closer">向前</button>
                <button id="move-away">向後</button>
            </div>
            <div class="info-text">
                提示：<br>• 單指拖動可旋轉模型<br>• 雙指縮放可調整大小
            </div>
        </div>
    </div>

    <script>
        // 定義共用變量
        const DUCK_MODEL_URL = 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Duck/glTF/Duck.gltf';
        
        // 在頁面載入時初始化並預載入模型
        window.onload = function() {
            console.log('頁面載入完成');
            
            // 預載入AR模型以確保後續AR體驗順暢
            fetch(DUCK_MODEL_URL)
                .then(response => response.json())
                .then(data => {
                    console.log('AR模型預載入成功');
                })
                .catch(error => {
                    console.error('AR模型預載入失敗:', error);
                });
                
            // 處理權限按鈕的點擊事件
            document.getElementById('grant-permission').addEventListener('click', function() {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    console.error('瀏覽器不支持getUserMedia API');
                    alert('您的瀏覽器不支持相機訪問');
                    return;
                }
                
                navigator.mediaDevices.getUserMedia({ video: true })
                .then(function(stream) {
                    console.log('相機權限授予成功');
                    // 停止流，因為我們只需要權限，不需要流本身
                    stream.getTracks().forEach(track => track.stop());
                    
                    // 使用新的初始化函數，確保AR場景正確設置
                    hideOverlayAndInitAR();
                })
                .catch(function(error) {
                    console.error('相機權限授予失敗:', error);
                    alert('無法訪問相機，請確保您已授予相機權限');
                });
            });
            
            // 重置權限按鈕點擊處理
            const resetButton = document.getElementById('reset-permission');
            if (resetButton) {
                resetButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    console.log('重置權限按鈕被點擊');
                    
                    // 清除本地存儲中的權限標記
                    localStorage.removeItem('cameraPermissionGranted');
                    
                    // 如果瀏覽器支持，嘗試重置相機權限
                    if (navigator.mediaDevices && navigator.permissions) {
                        navigator.permissions.query({name: 'camera'})
                            .then(function(permissionStatus) {
                                console.log('嘗試重置相機權限');
                                alert('權限已重置，請重新載入頁面。');
                                // 重新載入頁面
                                window.location.reload();
                            })
                            .catch(function(error) {
                                console.error('無法查詢權限狀態:', error);
                                alert('權限已重置，請重新載入頁面。');
                                // 重新載入頁面
                                window.location.reload();
                            });
                    } else {
                        alert('權限已重置，請重新載入頁面。');
                        // 重新載入頁面
                        window.location.reload();
                    }
                });
            }
            
            // 設置重置按鈕功能
            document.getElementById('reset-view').addEventListener('click', function() {
                console.log('重置模型位置和大小');
                const duckEntity = document.getElementById('duck');
                if (duckEntity) {
                    // 重置位置
                    duckEntity.setAttribute('position', '0 0 -2');
                    // 重置旋轉，保持90度X軸旋轉讓鴨子站立
                    duckEntity.setAttribute('rotation', '90 0 0');
                    // 重置縮放
                    duckEntity.setAttribute('scale', '0.3 0.3 0.3');
                }
            });
            
            // 設置自動旋轉按鈕功能
            let autoRotating = false;
            let rotationInterval;
            const autoRotateButton = document.getElementById('auto-rotate');
            
            autoRotateButton.addEventListener('click', function() {
                const duckEntity = document.getElementById('duck');
                if (!duckEntity) return;
                
                autoRotating = !autoRotating;
                
                if (autoRotating) {
                    autoRotateButton.textContent = '停止旋轉';
                    autoRotateButton.style.backgroundColor = '#e74c3c';
                    
                    // 啟動自動旋轉
                    rotationInterval = setInterval(function() {
                        const currentRotation = duckEntity.getAttribute('rotation');
                        duckEntity.setAttribute('rotation', {
                            x: currentRotation.x,
                            y: (currentRotation.y + 0.2) % 360,
                            z: currentRotation.z
                        });
                    }, 30);
                } else {
                    autoRotateButton.textContent = '自動旋轉';
                    autoRotateButton.style.backgroundColor = '#4CAF50';
                    
                    // 停止自動旋轉
                    clearInterval(rotationInterval);
                }
            });

            // 設置向前按鈕功能
            document.getElementById('move-closer').addEventListener('click', function() {
                const duckEntity = document.getElementById('duck');
                if (!duckEntity) return;
                
                const currentPosition = duckEntity.getAttribute('position');
                // z值減小，模型向前移動（接近相機）
                const newZ = Math.max(currentPosition.z - 0.5, -5);
                duckEntity.setAttribute('position', {
                    x: currentPosition.x,
                    y: currentPosition.y,
                    z: newZ
                });
            });
            
            // 設置向後按鈕功能
            document.getElementById('move-away').addEventListener('click', function() {
                const duckEntity = document.getElementById('duck');
                if (!duckEntity) return;
                
                const currentPosition = duckEntity.getAttribute('position');
                // z值增大，模型向後移動（遠離相機）
                const newZ = Math.min(currentPosition.z + 0.5, -1);
                duckEntity.setAttribute('position', {
                    x: currentPosition.x,
                    y: currentPosition.y,
                    z: newZ
                });
            });
        };

        // 檢查組件是否已註冊，如果已註冊則不再重複註冊
        if (!AFRAME.components['gesture-detector']) {
            // 註冊手勢檢測組件
            AFRAME.registerComponent('gesture-detector', {
                schema: {
                    element: { default: '' }
                },
                init: function() {
                    this.targetElement = this.data.element && document.querySelector(this.data.element);
                    if (!this.targetElement) {
                        this.targetElement = this.el;
                    }
                    
                    this.internalState = {
                        previousState: null,
                        mouseDown: false,
                        mouseButtons: { left: false, right: false, middle: false }, // 追蹤哪個按鈕被按下
                        mouseClickPosition: { x: 0, y: 0 } // 滑鼠點擊位置
                    };
                    
                    this.emitGestureEvent = this.emitGestureEvent.bind(this);
                    this.handleMouseDown = this.handleMouseDown.bind(this);
                    this.handleMouseMove = this.handleMouseMove.bind(this);
                    this.handleMouseUp = this.handleMouseUp.bind(this);
                    this.handleMouseWheel = this.handleMouseWheel.bind(this);
                    
                    // 觸摸事件監聽
                    this.targetElement.addEventListener('touchstart', this.emitGestureEvent);
                    this.targetElement.addEventListener('touchend', this.emitGestureEvent);
                    this.targetElement.addEventListener('touchmove', this.emitGestureEvent);
                    
                    // 滑鼠事件監聽
                    this.targetElement.addEventListener('mousedown', this.handleMouseDown);
                    this.targetElement.addEventListener('mousemove', this.handleMouseMove);
                    this.targetElement.addEventListener('mouseup', this.handleMouseUp);
                    this.targetElement.addEventListener('wheel', this.handleMouseWheel);
                },
                remove: function() {
                    // 移除觸摸事件監聽
                    this.targetElement.removeEventListener('touchstart', this.emitGestureEvent);
                    this.targetElement.removeEventListener('touchend', this.emitGestureEvent);
                    this.targetElement.removeEventListener('touchmove', this.emitGestureEvent);
                    
                    // 移除滑鼠事件監聽
                    this.targetElement.removeEventListener('mousedown', this.handleMouseDown);
                    this.targetElement.removeEventListener('mousemove', this.handleMouseMove);
                    this.targetElement.removeEventListener('mouseup', this.handleMouseUp);
                    this.targetElement.removeEventListener('wheel', this.handleMouseWheel);
                },
                // 處理滑鼠按下事件
                handleMouseDown: function(event) {
                    this.internalState.mouseDown = true;
                    
                    // 記錄按下的按鈕
                    switch (event.button) {
                        case 0: this.internalState.mouseButtons.left = true; break;
                        case 1: this.internalState.mouseButtons.middle = true; break;
                        case 2: this.internalState.mouseButtons.right = true; break;
                    }
                    
                    // 記錄滑鼠位置
                    this.internalState.mouseClickPosition = {
                        x: event.clientX / window.innerWidth,
                        y: event.clientY / window.innerHeight
                    };
                    
                    // 創建相應的事件
                    const mouseState = {
                        touchCount: 1, // 模擬單指觸摸
                        position: {
                            x: event.clientX / window.innerWidth,
                            y: event.clientY / window.innerHeight
                        },
                        startPosition: {
                            x: event.clientX / window.innerWidth,
                            y: event.clientY / window.innerHeight
                        },
                        startTime: performance.now()
                    };
                    
                    this.internalState.previousState = mouseState;
                    
                    // 模擬手指開始事件
                    this.el.emit('onefingerstart', mouseState);
                },
                // 處理滑鼠移動事件
                handleMouseMove: function(event) {
                    if (!this.internalState.mouseDown) return;
                    
                    const currentPosition = {
                        x: event.clientX / window.innerWidth,
                        y: event.clientY / window.innerHeight
                    };
                    
                    // 獲取前一個狀態
                    const previousState = this.internalState.previousState;
                    if (!previousState) return;
                    
                    // 創建事件詳情
                    const eventDetail = {
                        positionChange: {
                            x: currentPosition.x - previousState.position.x,
                            y: currentPosition.y - previousState.position.y
                        },
                        position: currentPosition,
                        movementDirection: this.getMovementDirection(previousState.position, currentPosition)
                    };
                    
                    // 更新前一個狀態
                    this.internalState.previousState.position = currentPosition;
                    
                    // 發出相應事件
                    if (this.internalState.mouseButtons.left) {
                        this.el.emit('onefingermove', eventDetail); // 左鍵 -> 旋轉
                    }
                },
                // 處理滑鼠放開事件
                handleMouseUp: function(event) {
                    // 重置滑鼠狀態
                    switch (event.button) {
                        case 0: this.internalState.mouseButtons.left = false; break;
                        case 1: this.internalState.mouseButtons.middle = false; break;
                        case 2: this.internalState.mouseButtons.right = false; break;
                    }
                    
                    // 檢查是否所有按鈕都被釋放
                    if (!this.internalState.mouseButtons.left && 
                        !this.internalState.mouseButtons.middle && 
                        !this.internalState.mouseButtons.right) {
                        this.internalState.mouseDown = false;
                    }
                    
                    // 發出相應事件
                    if (this.internalState.previousState) {
                        this.el.emit('onefingerend', this.internalState.previousState);
                        this.internalState.previousState = null;
                    }
                },
                // 處理滑鼠滾輪事件（用於縮放）
                handleMouseWheel: function(event) {
                    event.preventDefault();
                    
                    // 創建模擬的雙指手勢狀態
                    const twoFingerState = {
                        touchCount: 2,
                        position: {
                            x: event.clientX / window.innerWidth,
                            y: event.clientY / window.innerHeight
                        },
                        spread: 20, // 基準展開值
                        startSpread: 20,
                        startTime: performance.now(),
                        spreadChange: event.deltaY > 0 ? -5 : 5 // 根據滾輪方向決定縮放方向
                    };
                    
                    // 發送雙指移動事件以觸發縮放
                    this.el.emit('twofingermove', twoFingerState);
                },
                // 處理觸摸事件
                emitGestureEvent: function(event) {
                    // 防止滾動等默認行為
                    event.preventDefault();
                    
                    const currentState = this.getTouchState(event);
                    const previousState = this.internalState.previousState;
                    
                    const gestureContinues = previousState && currentState && 
                        currentState.touchCount === previousState.touchCount;
                    
                    const gestureEnded = previousState && !gestureContinues;
                    const gestureStarted = currentState && !gestureContinues;
                    
                    if (gestureEnded) {
                        const eventName = this.getEventPrefix(previousState.touchCount) + 'fingerend';
                        this.el.emit(eventName, previousState);
                        this.internalState.previousState = null;
                    }
                    
                    if (gestureStarted) {
                        currentState.startTime = performance.now();
                        currentState.startPosition = currentState.position;
                        currentState.startSpread = currentState.spread;
                        
                        const eventName = this.getEventPrefix(currentState.touchCount) + 'fingerstart';
                        this.el.emit(eventName, currentState);
                        this.internalState.previousState = currentState;
                    }
                    
                    if (gestureContinues) {
                        const eventDetail = {
                            positionChange: {
                                x: currentState.position.x - previousState.position.x,
                                y: currentState.position.y - previousState.position.y
                            }
                        };
                        
                        if (currentState.spread) {
                            eventDetail.spreadChange = currentState.spread - previousState.spread;
                        }
                        
                        // 在手指移動事件中加入方向判斷
                        if (currentState.touchCount === 1) {
                            const movementDirection = this.getMovementDirection(
                                previousState.position, 
                                currentState.position
                            );
                            eventDetail.movementDirection = movementDirection;
                        }
                        
                        Object.assign(eventDetail, currentState);
                        
                        const eventName = this.getEventPrefix(currentState.touchCount) + 'fingermove';
                        this.el.emit(eventName, eventDetail);
                        this.internalState.previousState = currentState;
                    }
                },
                getTouchState: function(event) {
                    if (event.touches.length === 0) {
                        return null;
                    }
                    
                    // 實施平均觸摸點
                    const touchList = [];
                    for (let i = 0; i < event.touches.length; i++) {
                        touchList.push(event.touches[i]);
                    }
                    
                    const touchState = {
                        touchCount: touchList.length
                    };
                    
                    // 計算觸摸點的平均位置
                    const centerPositionRawX = touchList.reduce((sum, touch) => sum + touch.clientX, 0) / touchList.length;
                    const centerPositionRawY = touchList.reduce((sum, touch) => sum + touch.clientY, 0) / touchList.length;
                    
                    touchState.positionRaw = { x: centerPositionRawX, y: centerPositionRawY };
                    
                    // 計算歸一化後的位置 (0.0 到 1.0)
                    touchState.position = { 
                        x: centerPositionRawX / window.innerWidth,
                        y: centerPositionRawY / window.innerHeight 
                    };
                    
                    // 計算多個手指時的平均展開距離
                    if (touchList.length >= 2) {
                        const spread = this.calculateSpread(touchList);
                        touchState.spread = spread;
                    }
                    
                    return touchState;
                },
                calculateSpread: function(touchList) {
                    let minX = touchList[0].clientX;
                    let maxX = touchList[0].clientX;
                    let minY = touchList[0].clientY;
                    let maxY = touchList[0].clientY;
                    
                    // 找出所有觸摸點的邊界框
                    for (let i = 1; i < touchList.length; i++) {
                        const touch = touchList[i];
                        
                        minX = Math.min(minX, touch.clientX);
                        maxX = Math.max(maxX, touch.clientX);
                        minY = Math.min(minY, touch.clientY);
                        maxY = Math.max(maxY, touch.clientY);
                    }
                    
                    // 使用歐幾里得距離作為展開度量
                    return Math.sqrt(
                        Math.pow(maxX - minX, 2) +
                        Math.pow(maxY - minY, 2)
                    );
                },
                getEventPrefix: function(touchCount) {
                    const numberNames = ['one', 'two', 'three', 'many'];
                    return numberNames[Math.min(touchCount, 4) - 1];
                },
                getMovementDirection: function(previousPosition, currentPosition) {
                    // 判斷手指移動的主要方向
                    const dx = currentPosition.x - previousPosition.x;
                    const dy = currentPosition.y - previousPosition.y;
                    
                    if (Math.abs(dx) > Math.abs(dy)) {
                        return dx > 0 ? 'right' : 'left';
                    } else {
                        return dy > 0 ? 'down' : 'up';
                    }
                }
            });
        }
        
        // 檢查組件是否已註冊，如果已註冊則不再重複註冊
        if (!AFRAME.components['gesture-handler']) {
            // 註冊手勢處理器
            AFRAME.registerComponent('gesture-handler', {
                schema: {
                    enabled: { default: true },
                    rotationFactor: { default: 5 },
                    minScale: { default: 0.1 },
                    maxScale: { default: 8 },
                    moveSpeed: { default: 0.01 },
                    sensitivityX: { default: 1 },
                    sensitivityY: { default: 1 }
                },
                
                init: function() {
                    this.handleScale = this.handleScale.bind(this);
                    this.handleRotation = this.handleRotation.bind(this);
                    
                    this.isVisible = false;
                    this.initialScale = this.el.object3D.scale.clone();
                    this.scaleFactor = 1;
                    
                    this.el.sceneEl.addEventListener('onefingermove', this.handleRotation);
                    this.el.sceneEl.addEventListener('twofingermove', this.handleScale);
                    
                    // 為方便調試添加事件監聽器
                    this.el.addEventListener('model-loaded', () => {
                        console.log('模型已加載 - 手勢處理器');
                        this.isVisible = true;
                    });
                },
                
                remove: function() {
                    this.el.sceneEl.removeEventListener('onefingermove', this.handleRotation);
                    this.el.sceneEl.removeEventListener('twofingermove', this.handleScale);
                },
                
                handleRotation: function(event) {
                    console.log('單指移動事件');
                    if (this.isVisible && this.data.enabled) {
                        // 根據拖動執行旋轉
                        this.el.object3D.rotation.y += event.detail.positionChange.x * this.data.rotationFactor * this.data.sensitivityX;
                        this.el.object3D.rotation.x += event.detail.positionChange.y * this.data.rotationFactor * this.data.sensitivityY;
                        console.log('旋轉更新為:', this.el.object3D.rotation);
                    }
                },
                
                handleScale: function(event) {
                    console.log('雙指縮放事件');
                    if (this.isVisible && this.data.enabled) {
                        // 縮放
                        this.scaleFactor *=  1 + event.detail.spreadChange / event.detail.startSpread;
                        
                        // 限制縮放比例在最小和最大值之間
                        this.scaleFactor = Math.min(Math.max(this.scaleFactor, this.data.minScale), this.data.maxScale);
                        
                        // 應用縮放
                        this.el.object3D.scale.x = this.scaleFactor * this.initialScale.x;
                        this.el.object3D.scale.y = this.scaleFactor * this.initialScale.y;
                        this.el.object3D.scale.z = this.scaleFactor * this.initialScale.z;
                        
                        console.log('縮放更新為:', this.scaleFactor);
                    }
                }
            });
        }

        AFRAME.registerComponent('clickable', {
            init: function() {
                this.el.addEventListener('click', function() {
                    console.log('點擊!');
                });
            }
        });

        // 監聽自定義的相機權限授予事件
        document.addEventListener('camera-permission-granted', function() {
            console.log('接收到相機權限已授予事件');
            // 確保AR場景顯示並正確初始化
            const arScene = document.querySelector('a-scene');
            if (arScene) {
                // 確保場景可見
                arScene.style.visibility = 'visible';
                arScene.style.opacity = '1';
            }
        });

        // 確保鴨子模型顯示
        function ensureDuckVisible() {
            console.log('確保鴨子模型顯示');
            const duckEntity = document.getElementById('duck');
            
            // 檢查主模型是否存在
            if (duckEntity) {
                console.log('找到鴨子模型，嘗試設置可見性');
                // 強制設置可見性
                duckEntity.setAttribute('visible', 'true');
                
                // 如果有object3D，直接設置其可見性
                if (duckEntity.object3D) {
                    duckEntity.object3D.visible = true;
                    console.log('鴨子模型 object3D 設置為可見');
                } else {
                    console.warn('鴨子模型沒有 object3D');
                }
                
                // 確保位置正確
                duckEntity.setAttribute('position', '0 0 -2');
                duckEntity.setAttribute('rotation', '90 0 0');
                duckEntity.setAttribute('scale', '0.3 0.3 0.3');
                
                // 確保手勢處理器存在
                if (!duckEntity.hasAttribute('gesture-handler')) {
                    console.log('添加手勢處理器到鴨子模型');
                    duckEntity.setAttribute('gesture-handler', 'minScale: 0.1; maxScale: 1.0');
                }
                
                // 確保clickable類存在
                if (!duckEntity.classList.contains('clickable')) {
                    console.log('添加clickable類到鴨子模型');
                    duckEntity.classList.add('clickable');
                }
                
                console.log('鴨子模型設置完成');
                
                // 監聽模型加載錯誤事件
                duckEntity.addEventListener('model-error', function(event) {
                    console.error('鴨子模型加載失敗:', event);
                    showBackupModel();
                });
                
                // 檢查模型是否正確加載
                setTimeout(function() {
                    if (!duckEntity.object3D || !duckEntity.object3D.children || duckEntity.object3D.children.length === 0) {
                        console.warn('鴨子模型似乎未正確加載，顯示備用模型');
                        showBackupModel();
                    }
                }, 3000);
            } else {
                console.error('找不到鴨子模型，顯示備用模型');
                showBackupModel();
            }
        }
        
        // 顯示備用模型
        function showBackupModel() {
            console.log('顯示備用模型');
            const backupModel = document.getElementById('backup-model');
            if (backupModel) {
                backupModel.setAttribute('visible', 'true');
                console.log('備用模型設置為可見');
            } else {
                console.error('找不到備用模型');
                
                // 嘗試手動創建備用模型
                const scene = document.querySelector('a-scene');
                if (scene) {
                    console.log('嘗試手動創建備用模型');
                    const newBox = document.createElement('a-box');
                    newBox.id = 'backup-model';
                    newBox.setAttribute('position', '0 0 -2');
                    newBox.setAttribute('scale', '0.2 0.2 0.2');
                    newBox.setAttribute('color', 'yellow');
                    newBox.setAttribute('visible', 'true');
                    scene.appendChild(newBox);
                    console.log('手動創建備用模型完成');
                }
            }
        }

        // 隱藏權限覆蓋層並初始化AR場景
        function hideOverlayAndInitAR() {
            // 隱藏權限覆蓋層
            document.getElementById('permission-overlay').style.display = 'none';
            
            // 重新啟動AR.js
            document.querySelector('a-scene').addEventListener('loaded', function () {
                console.log('AR場景已加載');
                // 確保鴨子模型在場景加載後可見
                setTimeout(ensureDuckVisible, 1000);
            });
            
            // 加載模型
            preloadModel('/3d/duck.glb');
        }
    </script>
</body>
</html> 